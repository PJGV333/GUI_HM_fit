 (cd "$(git rev-parse --show-toplevel)" && git apply --3way <<'EOF' 
diff --git a/backend_fastapi/config.py b/backend_fastapi/config.py
new file mode 100644
index 0000000000000000000000000000000000000000..a8dab45eb10b9e0fe94034e5ebda61f2b127506a
--- /dev/null
+++ b/backend_fastapi/config.py
@@ -0,0 +1,49 @@
+"""Configuration helpers for the FastAPI backend.
+
+This module centralizes environment-driven settings so switching machines
+only requires updating environment variables (no code edits).
+"""
+
+import os
+from typing import List, Optional
+
+# Environment: "dev" enables permissive localhost CORS for Vite; any other
+# value (e.g., "prod") tightens to the packaged Tauri origins.
+HM_FIT_ENV = os.getenv("HM_FIT_ENV", "dev").lower()
+
+# Host/port for the FastAPI server. Defaults match the existing workspace
+# conventions but can be overridden per machine.
+BACKEND_HOST = os.getenv("HM_FIT_BACKEND_HOST", "127.0.0.1")
+BACKEND_PORT = int(os.getenv("HM_FIT_BACKEND_PORT", "8001"))
+
+# CORS settings depend on environment. In dev we allow common localhost
+# variants plus a regex to cover arbitrary localhost ports. In prod we
+# explicitly allow the Tauri origin.
+DEV_ORIGINS: List[str] = [
+    "http://localhost",
+    "http://localhost:5173",
+    "http://localhost:1420",  # Tauri dev server
+    "http://127.0.0.1",
+    "http://127.0.0.1:5173",
+    "http://127.0.0.1:1420",
+    "tauri://localhost",  # Some Tauri builds keep this origin even in dev
+]
+
+PROD_ORIGINS: List[str] = [
+    "tauri://localhost",
+]
+
+if HM_FIT_ENV == "dev":
+    # Allow enumerated localhost hosts plus any localhost/127 port via regex so
+    # the app "just works" across machines and dev setups without CORS edits.
+    CORS_ALLOW_ORIGINS: List[str] = DEV_ORIGINS
+    CORS_ALLOW_ORIGIN_REGEX: Optional[str] = r"(https?|tauri)://(localhost|127\.0\.0\.1)(:\d+)?"
+else:
+    # Production: restrict to the packaged Tauri origin.
+    CORS_ALLOW_ORIGINS = PROD_ORIGINS
+    CORS_ALLOW_ORIGIN_REGEX = r"tauri://localhost"
+
+# Shared CORS flags
+CORS_ALLOW_METHODS = ["*"]
+CORS_ALLOW_HEADERS = ["*"]
+CORS_ALLOW_CREDENTIALS = True
diff --git a/backend_fastapi/main.py b/backend_fastapi/main.py
index a634470d11dc5192e503b403bfbe99cf9a9c26fd..45b58f4a85e4cffbf42edeac7032a955a303a6fd 100644
--- a/backend_fastapi/main.py
+++ b/backend_fastapi/main.py
@@ -1,89 +1,137 @@
-"""FastAPI backend for HM Fit - Full version with JAX processing.
+"""FastAPI backend for HM Fit.
 
 Includes:
-- WebSocket for progress streaming
-- Direct file processing (no sessions) to avoid hangs
-- JAX-based spectroscopy processing
+- WebSocket for progress streaming.
+- Spectroscopy processing using the refactored business logic.
+- Lightweight NMR endpoints so the Tauri frontend can be wired without
+  reimplementing scientific code.
 """
 from fastapi import FastAPI, UploadFile, File, Form, HTTPException, WebSocket, WebSocketDisconnect
 from pydantic import BaseModel
 import uvicorn
 import pandas as pd
 import io
 import os
 import time
 import tempfile
 import shutil
 from pathlib import Path
 from typing import Dict, Optional
 import asyncio
 import json
 from fastapi.middleware.cors import CORSMiddleware
 
+from backend_fastapi import nmr_processor
+from backend_fastapi.config import (
+    BACKEND_HOST,
+    BACKEND_PORT,
+    CORS_ALLOW_CREDENTIALS,
+    CORS_ALLOW_HEADERS,
+    CORS_ALLOW_METHODS,
+    CORS_ALLOW_ORIGIN_REGEX,
+    CORS_ALLOW_ORIGINS,
+    HM_FIT_ENV,
+)
+
 app = FastAPI(title="HM Fit FastAPI prototype")
+app.state.hm_fit_env = HM_FIT_ENV
+
+
+def _log_cors_settings():
+    print(
+        "[HM Fit] CORS settings => env=", HM_FIT_ENV,
+        "allow_origins=", CORS_ALLOW_ORIGINS,
+        "allow_origin_regex=", CORS_ALLOW_ORIGIN_REGEX,
+    )
+
 
+# CORS configuration: in dev allow localhost variants (and a regex for any port);
+# in prod tighten to Tauri origins. See backend_fastapi/config.py for details.
 app.add_middleware(
     CORSMiddleware,
-    allow_origins=["*"],
-    allow_credentials=True,
-    allow_methods=["*"],
-    allow_headers=["*"],
+    allow_origins=CORS_ALLOW_ORIGINS,
+    allow_origin_regex=CORS_ALLOW_ORIGIN_REGEX,
+    allow_credentials=CORS_ALLOW_CREDENTIALS,
+    allow_methods=CORS_ALLOW_METHODS,
+    allow_headers=CORS_ALLOW_HEADERS,
 )
+_log_cors_settings()
 
 # Temporary directory for uploaded files
 UPLOAD_DIR = Path(tempfile.gettempdir()) / "hmfit_uploads"
 UPLOAD_DIR.mkdir(exist_ok=True)
 
 # WebSocket connections
 active_connections: list[WebSocket] = []
 
 @app.get("/health")
 def health():
     """Health check endpoint."""
     return {"status": "ok"}
 
 @app.post("/list_sheets")
 async def list_sheets(file: UploadFile = File(...)):
     """Receive Excel file and return list of sheet names."""
     try:
         contents = await file.read()
         xl = pd.ExcelFile(io.BytesIO(contents))
         return {"sheets": xl.sheet_names}
     except Exception as e:
         raise HTTPException(status_code=400, detail=f"Error reading Excel file: {str(e)}")
 
 @app.post("/list_columns")
 async def list_columns(file: UploadFile = File(...), sheet_name: str = Form(...)):
     """Receive Excel file and sheet name, return column names."""
     try:
         contents = await file.read()
         df = pd.read_excel(io.BytesIO(contents), sheet_name=sheet_name, nrows=0)
         return {"columns": list(df.columns)}
     except Exception as e:
         raise HTTPException(status_code=400, detail=f"Error reading columns: {str(e)}")
 
+
+@app.post("/nmr/list_sheets")
+async def nmr_list_sheets(file: UploadFile = File(...)):
+    """Expose workbook sheet names for the NMR flow (same as spectroscopy)."""
+    try:
+        contents = await file.read()
+        return {"sheets": nmr_processor.list_sheets_from_bytes(contents)}
+    except Exception as e:
+        raise HTTPException(status_code=400, detail=f"Error reading Excel file: {str(e)}")
+
+
+@app.post("/nmr/list_columns")
+async def nmr_list_columns(file: UploadFile = File(...), sheet_name: str = Form(...)):
+    """Expose sheet columns for the NMR flow."""
+    try:
+        contents = await file.read()
+        columns = nmr_processor.list_columns_from_bytes(contents, sheet_name)
+        return {"columns": columns}
+    except Exception as e:
+        raise HTTPException(status_code=400, detail=f"Error reading columns: {str(e)}")
+
 @app.websocket("/ws/progress")
 async def websocket_progress(websocket: WebSocket):
     """WebSocket endpoint for streaming progress updates."""
     await websocket.accept()
     active_connections.append(websocket)
     try:
         while True:
             # Keep connection alive
             await asyncio.sleep(1)
     except WebSocketDisconnect:
         active_connections.remove(websocket)
 
 async def broadcast_progress(message: str):
     """Broadcast progress message to all connected WebSocket clients."""
     for connection in active_connections:
         try:
             await connection.send_text(json.dumps({"type": "progress", "message": message}))
         except:
             pass
 
 @app.post("/process_spectroscopy")
 async def process_spectroscopy(
     file: UploadFile = File(...),
     spectra_sheet: str = Form(...),
     conc_sheet: str = Form(...),
@@ -160,33 +208,81 @@ async def process_spectroscopy(
         
         # Send initial message
         await broadcast_progress("Iniciando procesamiento de datos (en hilo separado)...")
         
         # Run in executor (thread pool) to avoid blocking event loop
         results = await loop.run_in_executor(None, run_processing_in_thread)
         
         # Clean up temp file
         try:
             os.remove(temp_path)
         except:
             pass
         
         # Send completion message
         await broadcast_progress("Procesamiento completado!")
         
         return results
         
     except Exception as e:
         error_msg = f"Error en procesamiento: {str(e)}"
         await broadcast_progress(error_msg)
         import traceback
         traceback.print_exc()
         raise HTTPException(status_code=500, detail=error_msg)
 
+
+@app.post("/process_nmr")
+async def process_nmr(
+    file: UploadFile = File(...),
+    spectra_sheet: str = Form(...),
+    conc_sheet: str = Form(...),
+    column_names: str = Form(...),  # JSON string
+    signals_sheet: str = Form(""),
+    receptor_label: str = Form(""),
+    guest_label: str = Form("")
+):
+    """
+    Lightweight placeholder to wire the Tauri NMR tab.
+
+    The function echoes back workbook selections so the frontend can be
+    connected without duplicating the numerical NMR code.  The shape of
+    the response is stable to allow swapping in the full solver later.
+    """
+    try:
+        import json
+
+        column_names_list = json.loads(column_names)
+
+        # Save file temporarily
+        temp_path = UPLOAD_DIR / f"temp_nmr_{int(time.time())}_{file.filename}"
+        with open(temp_path, "wb") as buffer:
+            shutil.copyfileobj(file.file, buffer)
+
+        results = nmr_processor.summarize_nmr_inputs(
+            file_path=str(temp_path),
+            spectra_sheet=spectra_sheet,
+            conc_sheet=conc_sheet,
+            column_names=column_names_list,
+            signals_sheet=signals_sheet or None,
+            receptor_label=receptor_label or None,
+            guest_label=guest_label or None,
+        )
+
+        try:
+            os.remove(temp_path)
+        except Exception:
+            pass
+
+        return results
+
+    except Exception as e:
+        error_msg = f"Error en procesamiento NMR: {str(e)}"
+        raise HTTPException(status_code=500, detail=error_msg)
+
 if __name__ == "__main__":
-    port = int(os.environ.get("HM_BACKEND_PORT", "8000"))
     uvicorn.run(
         "backend_fastapi.main:app",
-        host="127.0.0.1",
-        port=port,
+        host=BACKEND_HOST,
+        port=BACKEND_PORT,
         reload=True,
     )
diff --git a/backend_fastapi/nmr_processor.py b/backend_fastapi/nmr_processor.py
new file mode 100644
index 0000000000000000000000000000000000000000..b66a74fd02316c0415ca4a667bdfb52b6ab670e8
--- /dev/null
+++ b/backend_fastapi/nmr_processor.py
@@ -0,0 +1,77 @@
+"""
+Minimal NMR backend hooks exposed to the Tauri frontend.
+
+The logic here is intentionally lightweight: it mirrors the workbook
+loading flow of ``NMR_controls.py`` (file → sheet selection → column
+selection) and returns structured placeholders that the frontend can
+consume without reimplementing scientific details.  The numerical core
+from ``NMR_controls.py`` can be integrated later behind the same
+function signatures.
+"""
+from __future__ import annotations
+
+from pathlib import Path
+from typing import Dict, List, Optional
+import base64
+import io
+
+import pandas as pd
+
+
+def list_sheets_from_bytes(file_bytes: bytes) -> List[str]:
+    """Return available sheet names from an Excel workbook."""
+    xl = pd.ExcelFile(io.BytesIO(file_bytes))
+    return xl.sheet_names
+
+
+def list_columns_from_bytes(file_bytes: bytes, sheet_name: str) -> List[str]:
+    """Return column headers for a given sheet."""
+    df = pd.read_excel(io.BytesIO(file_bytes), sheet_name=sheet_name, nrows=0)
+    return list(df.columns)
+
+
+def summarize_nmr_inputs(
+    *,
+    file_path: str,
+    spectra_sheet: str,
+    conc_sheet: str,
+    column_names: List[str],
+    signals_sheet: Optional[str] = None,
+    receptor_label: str | None = None,
+    guest_label: str | None = None,
+) -> Dict:
+    """
+    Lightweight placeholder that mirrors the wxPython workflow:
+    - Reads the selected sheets.
+    - Echoes back the chosen columns and simple sizes.
+
+    This allows the frontend to be wired without duplicating scientific
+    logic.  The full NMR fit can later replace this function while
+    keeping the same shape of the response payload.
+    """
+    spectra_df = pd.read_excel(file_path, spectra_sheet, header=0, index_col=0)
+    conc_df = pd.read_excel(file_path, conc_sheet, header=0)
+
+    selected_columns = conc_df[column_names]
+
+    # Optional chemical shift sheet: present in wx GUI
+    signals = None
+    if signals_sheet:
+        signals = pd.read_excel(file_path, signals_sheet, header=0, index_col=0)
+
+    payload = {
+        "success": True,
+        "n_points": int(len(spectra_df.index)),
+        "n_traces": int(spectra_df.shape[1]),
+        "n_concentrations": int(selected_columns.shape[1]),
+        "columns": list(selected_columns.columns),
+        "receptor_label": receptor_label or "",
+        "guest_label": guest_label or "",
+        "signals_sheet": signals_sheet or "",
+    }
+
+    if signals is not None:
+        payload["n_signals"] = int(signals.shape[0])
+        payload["signal_axis"] = list(map(str, signals.index))
+
+    return payload
diff --git a/hmfit_tauri/src/backend/config.js b/hmfit_tauri/src/backend/config.js
new file mode 100644
index 0000000000000000000000000000000000000000..2717a7109873db0a98c6cde778cb503f921c50b5
--- /dev/null
+++ b/hmfit_tauri/src/backend/config.js
@@ -0,0 +1,13 @@
+// Centralized backend configuration for HM Fit.
+// Reads Vite/Tauri env vars when available; falls back to sensible defaults
+// so the app works across machines without code changes.
+
+const host = (import.meta?.env?.VITE_BACKEND_HOST || "127.0.0.1").trim();
+const port = (import.meta?.env?.VITE_BACKEND_PORT || "8001").trim();
+
+export const BACKEND_BASE_URL = `http://${host}:${port}`;
+export const WS_BASE_URL = `ws://${host}:${port}`;
+
+export function describeBackendTarget() {
+  return `${host}:${port}`;
+}
diff --git a/hmfit_tauri/src/main.js b/hmfit_tauri/src/main.js
index b9124080e30586f8dc7e35cf68f90cee8e19e330..592a7c30f422de9dc50320113954a1a8b8a883ce 100644
--- a/hmfit_tauri/src/main.js
+++ b/hmfit_tauri/src/main.js
@@ -1,44 +1,140 @@
 import "./style.css";
-
-const BACKEND_BASE = "http://127.0.0.1:8001";
-const WS_BASE = "ws://127.0.0.1:8001";
+import { BACKEND_BASE_URL, WS_BASE_URL, describeBackendTarget } from "./backend/config";
 
 const state = {
   activeModule: "spectroscopy", // "spectroscopy" | "nmr"
   activeSubtab: "model",        // "model" | "optimization"
   uploadedFile: null,            // Currently selected file
 };
 
 // WebSocket for progress streaming
 let progressWs = null;
 let isProcessing = false;
 
+// --- Backend client (shared fetch + helpers) ---
+async function ensureBackendReachable(baseError) {
+  try {
+    const healthResp = await fetch(`${BACKEND_BASE_URL}/health`);
+    if (!healthResp.ok) {
+      const detail = await healthResp.text();
+      throw new Error(
+        `/health respondió ${healthResp.status}: ${detail || healthResp.statusText}`,
+      );
+    }
+  } catch (healthErr) {
+    throw new Error(
+      `Backend no accesible en ${BACKEND_BASE_URL}. Asegúrate de que el servidor FastAPI ` +
+      `esté levantado en ${describeBackendTarget()} y que no haya un firewall bloqueándolo. ` +
+      `Detalle: ${healthErr?.message || healthErr}`,
+    );
+  }
+
+  // Health is reachable; bubble the original error for context.
+  throw baseError;
+}
+
+async function assertBackendAvailable() {
+  try {
+    const healthResp = await fetch(`${BACKEND_BASE_URL}/health`);
+    if (!healthResp.ok) {
+      const detail = await healthResp.text();
+      throw new Error(
+        `/health respondió ${healthResp.status}: ${detail || healthResp.statusText}`,
+      );
+    }
+  } catch (err) {
+    throw new Error(
+      `Backend no accesible en ${BACKEND_BASE_URL}. ` +
+      `Asegúrate de que el servidor FastAPI esté levantado en ${describeBackendTarget()} ` +
+      `y que no haya un firewall bloqueándolo. Detalle: ${err?.message || err}`,
+    );
+  }
+}
+
+async function callBackend(path, options = {}) {
+  const { method = "GET", body } = options;
+  const url = `${BACKEND_BASE_URL}${path}`;
+  let resp;
+
+  try {
+    resp = await fetch(url, { method, body, credentials: "include", mode: "cors" });
+  } catch (err) {
+    console.error(`[HM Fit] Network/CORS error calling ${url}:`, err);
+    await ensureBackendReachable(err);
+  }
+
+  if (!resp.ok) {
+    let detail;
+    try {
+      const errJson = await resp.json();
+      detail = errJson.detail || JSON.stringify(errJson);
+    } catch (_) {
+      detail = await resp.text();
+    }
+
+    const error = new Error(`HTTP ${resp.status} ${resp.statusText}: ${detail}`);
+    error.status = resp.status;
+    error.statusText = resp.statusText;
+    error.body = detail;
+    console.error(`[HM Fit] Backend error for ${url}:`, {
+      status: resp.status,
+      statusText: resp.statusText,
+      body: detail,
+    });
+    throw error;
+  }
+
+  return resp.json();
+}
+
+const backendApi = {
+  listSheets(file, mode = "spectroscopy") {
+    const formData = new FormData();
+    formData.append("file", file);
+    const path = mode === "nmr" ? "/nmr/list_sheets" : "/list_sheets";
+    return callBackend(path, { method: "POST", body: formData });
+  },
+  listColumns(file, sheetName, mode = "spectroscopy") {
+    const formData = new FormData();
+    formData.append("file", file);
+    formData.append("sheet_name", sheetName);
+    const path = mode === "nmr" ? "/nmr/list_columns" : "/list_columns";
+    return callBackend(path, { method: "POST", body: formData });
+  },
+  processSpectroscopy(formData) {
+    return callBackend("/process_spectroscopy", { method: "POST", body: formData });
+  },
+  processNmr(formData) {
+    return callBackend("/process_nmr", { method: "POST", body: formData });
+  },
+};
+
 function connectWebSocket() {
   if (progressWs && progressWs.readyState === WebSocket.OPEN) return;
 
-  progressWs = new WebSocket(`${WS_BASE}/ws/progress`);
+  progressWs = new WebSocket(`${WS_BASE_URL}/ws/progress`);
 
   progressWs.onopen = () => {
     console.log("WebSocket connected");
   };
 
   progressWs.onmessage = (event) => {
     try {
       const data = JSON.parse(event.data);
       if (data.type === "progress") {
         appendLog(data.message);
       }
     } catch (err) {
       console.error("WebSocket message error:", err);
     }
   };
 
   progressWs.onerror = (error) => {
     console.error("WebSocket error:", error);
   };
 
   progressWs.onclose = () => {
     console.log("WebSocket disconnected");
     // Reconnect after 2 seconds
     setTimeout(connectWebSocket, 2000);
   };
@@ -48,66 +144,66 @@ function log(text) {
   const pre = document.getElementById("log-output");
   if (!pre) return;
   pre.textContent = text;
 }
 
 function appendLog(text) {
   const pre = document.getElementById("log-output");
   if (!pre) return;
   pre.textContent += text + "\n";
   // Auto-scroll to bottom
   pre.scrollTop = pre.scrollHeight;
 }
 
 function setProcessing(active) {
   isProcessing = active;
   const processBtn = document.getElementById("process-btn");
   if (processBtn) {
     processBtn.disabled = active;
     processBtn.textContent = active ? "Processing..." : "Process Data";
   }
 }
 
 async function pingBackend() {
   log("Consultando /health …");
   try {
-    const resp = await fetch(`${BACKEND_BASE}/health`);
+    const resp = await fetch(`${BACKEND_BASE_URL}/health`);
     const data = await resp.json();
     log(JSON.stringify(data, null, 2));
   } catch (err) {
     log(`Error al consultar /health: ${err}`);
   }
 }
 
 async function dummyFit() {
   log("Enviando ejemplo a /dummy_fit …");
   try {
     const payload = {
       x: [0, 1, 2, 3],
       y: [0.1, 0.5, 0.9, 1.2],
     };
-    const resp = await fetch(`${BACKEND_BASE}/dummy_fit`, {
+    const resp = await fetch(`${BACKEND_BASE_URL}/dummy_fit`, {
       method: "POST",
       headers: { "Content-Type": "application/json" },
       body: JSON.stringify(payload),
     });
     const data = await resp.json();
     log(JSON.stringify(data, null, 2));
   } catch (err) {
     log(`Error al llamar /dummy_fit: ${err}`);
   }
 }
 
 function resetCalculation() {
   log("Esperando...");
 }
 
 function updateUI() {
   // Tabs: módulo (Spectroscopy / NMR)
   document.querySelectorAll("[data-module-tab]").forEach((btn) => {
     const mod = btn.dataset.moduleTab;
     if (mod === state.activeModule) {
       btn.classList.add("tab-active");
     } else {
       btn.classList.remove("tab-active");
     }
   });
@@ -124,50 +220,52 @@ function updateUI() {
 
   document.querySelectorAll("[data-subtab-panel]").forEach((panel) => {
     const sub = panel.dataset.subtabPanel;
     if (sub === state.activeSubtab) {
       panel.classList.add("subtab-visible");
     } else {
       panel.classList.remove("subtab-visible");
     }
   });
 
   // EFA solo en Spectroscopy
   const efaRow = document.querySelector(".efa-row");
   if (efaRow) {
     if (state.activeModule === "nmr") {
       efaRow.classList.add("hidden");
     } else {
       efaRow.classList.remove("hidden");
     }
   }
 }
 
 function initApp() {
   const app = document.querySelector("#app");
   if (!app) return;
 
+  console.info("[HM Fit] Backend base URL:", BACKEND_BASE_URL);
+
   app.innerHTML = `
     <div class="root-container">
       <header class="hmfit-header">
         <div>
           <h1 class="hmfit-title">HM Fit</h1>
           <p class="hmfit-subtitle">Hard Modeling · Spectroscopy &amp; NMR</p>
         </div>
       </header>
 
       <nav class="top-tabs">
         <button class="tab-btn" data-module-tab="spectroscopy">Spectroscopy</button>
         <button class="tab-btn" data-module-tab="nmr">NMR</button>
       </nav>
 
       <section class="layout">
         <!-- Panel izquierdo -->
         <div class="left-panel">
           <!-- Selección de archivo -->
           <section class="panel file-panel">
             <label class="field-label">Select Excel File</label>
             <div class="file-row">
               <input type="file" id="excel-file" class="file-input" />
               <span class="file-status">No file selected</span>
             </div>
 
@@ -499,119 +597,94 @@ function wireSpectroscopyForm() {
   }
   if (optimizerSelect) {
     ["powell", "nelder-mead", "trust-constr", "cg", "bfgs", "l-bfgs-b", "tnc", "cobyla", "slsqp", "differential_evolution"].forEach(opt => {
       const el = document.createElement("option");
       el.value = opt;
       el.text = opt;
       optimizerSelect.add(el);
     });
   }
 
   // --- Handler: File Selection ---
   const fileInput = document.getElementById("excel-file");
   const fileStatus = document.querySelector(".file-status");
 
   fileInput?.addEventListener("change", async (e) => {
     const file = e.target.files[0];
     if (!file) {
       fileStatus.textContent = "No file selected";
       state.uploadedFile = null;
       return;
     }
     fileStatus.textContent = file.name;
     state.uploadedFile = file;
 
     // Enviar al backend para obtener hojas
-    const formData = new FormData();
-    formData.append("file", file);
-
     try {
       diagEl.textContent = "Leyendo archivo Excel...";
-      const resp = await fetch(`${BACKEND_BASE}/list_sheets`, {
-        method: "POST",
-        body: formData,
-      });
-
-      if (!resp.ok) {
-        throw new Error(`Error ${resp.status}: ${await resp.text()}`);
-      }
-
-      const data = await resp.json();
-      const sheets = data.sheets || [];
+      const data = await backendApi.listSheets(file, state.activeModule);
+      const sheets = data?.sheets || [];
 
       // Poblar dropdowns
       [spectraSheetInput, concSheetInput].forEach(select => {
         if (!select) return;
         select.innerHTML = ""; // Limpiar
         if (sheets.length === 0) {
           const opt = document.createElement("option");
           opt.text = "No sheets found";
           select.add(opt);
         } else {
           sheets.forEach(sheet => {
             const opt = document.createElement("option");
             opt.value = sheet;
             opt.text = sheet;
             select.add(opt);
           });
         }
       });
       diagEl.textContent = `Archivo cargado. ${sheets.length} hojas encontradas.`;
 
     } catch (err) {
       console.error(err);
       diagEl.textContent = `Error al leer Excel: ${err.message}`;
     }
   });
 
   // --- Handler: Concentration Sheet Selection ---
   concSheetInput?.addEventListener("change", async () => {
     const sheetName = concSheetInput.value;
     const file = fileInput.files[0];
 
     if (!sheetName || !file) {
       columnsContainer.innerHTML = "Select a concentration sheet to load columns...";
       return;
     }
 
-    const formData = new FormData();
-    formData.append("file", file);
-    formData.append("sheet_name", sheetName);
-
     try {
       diagEl.textContent = `Leyendo columnas de ${sheetName}...`;
-      const resp = await fetch(`${BACKEND_BASE}/list_columns`, {
-        method: "POST",
-        body: formData,
-      });
-
-      if (!resp.ok) {
-        throw new Error(`Error ${resp.status}: ${await resp.text()}`);
-      }
-
-      const data = await resp.json();
-      const columns = data.columns || [];
+      const data = await backendApi.listColumns(file, sheetName, state.activeModule);
+      const columns = data?.columns || [];
 
       columnsContainer.innerHTML = ""; // Limpiar
       if (columns.length === 0) {
         columnsContainer.textContent = "No columns found.";
       } else {
         columns.forEach(col => {
           const label = document.createElement("label");
           label.className = "checkbox-inline";
           label.style.marginRight = "10px";
 
           const cb = document.createElement("input");
           cb.type = "checkbox";
           cb.value = col;
           cb.name = "column_names"; // Para facilitar recolección si se desea
 
           const span = document.createElement("span");
           span.textContent = col;
 
           label.appendChild(cb);
           label.appendChild(span);
           columnsContainer.appendChild(label);
         });
       }
       diagEl.textContent = `Columnas cargadas de ${sheetName}.`;
 
@@ -844,52 +917,62 @@ function wireSpectroscopyForm() {
       guestInput.value = "";
     }
     if (efaEigenInput) efaEigenInput.value = "0";
     if (nCompInput) nCompInput.value = "0";
     if (nSpeciesInput) nSpeciesInput.value = "0";
     if (efaCheckbox) efaCheckbox.checked = false;
     if (efaCheckbox) efaCheckbox.checked = false;
     if (modelGridContainer) modelGridContainer.innerHTML = "";
     if (optGridContainer) optGridContainer.innerHTML = "";
 
     diagEl.textContent = "Esperando...";
   });
 
   // --- Handler: Process Data ---
   processBtn.addEventListener("click", async () => {
     if (isProcessing) {
       appendLog("Procesamiento en curso, espera a que termine...");
       return;
     }
 
     if (!state.uploadedFile) {
       diagEl.textContent = "Error: No file selected. Please select a file first.";
       return;
     }
 
-    connectWebSocket();
     setProcessing(true);
+    diagEl.textContent = "Verificando backend...\n";
+    try {
+      await assertBackendAvailable();
+    } catch (err) {
+      diagEl.textContent = err.message || String(err);
+      setProcessing(false);
+      console.error("[HM Fit] Backend check failed before processing:", err);
+      return;
+    }
+
+    connectWebSocket();
     diagEl.textContent = "Procesando datos de Spectroscopy...\n";
 
     // Recolectar columnas seleccionadas
     const selectedCols = Array.from(columnsContainer.querySelectorAll('input[type="checkbox"]:checked'))
       .map(cb => cb.value);
 
     // Recolectar datos del grid del modelo
     const gridData = [];
     if (modelGridContainer) {
       const rows = modelGridContainer.querySelectorAll("tbody tr");
       rows.forEach(row => {
         const inputs = row.querySelectorAll(".grid-input");
         const rowData = Array.from(inputs).map(inp => parseFloat(inp.value) || 0);
         gridData.push(rowData);
       });
     }
 
     // Extraer especies no absorbentes
     const nonAbsSpecies = modelGridContainer
       ? Array.from(modelGridContainer.querySelectorAll("tr.selected"))
         .map(tr => parseInt(tr.dataset.species.replace('sp', '')) - 1)
       : [];
 
     // Extraer parámetros de optimización (K values)
     const kValues = [];
@@ -900,135 +983,157 @@ function wireSpectroscopyForm() {
         const inputs = row.querySelectorAll(".grid-input");
         if (inputs.length >= 3) {
           const val = parseFloat(inputs[0].value);
           const min = parseFloat(inputs[1].value);
           const max = parseFloat(inputs[2].value);
 
           // Use Number.isNaN to check for valid numbers, allowing 0
           const finalVal = Number.isNaN(val) ? 1.0 : val;
           const finalMin = Number.isNaN(min) ? -20 : min;
           const finalMax = Number.isNaN(max) ? 20 : max;
 
           kValues.push(finalVal);
           kBounds.push([finalMin, finalMax]);
         }
       });
     }
 
     // Create FormData with file and parameters
     const formData = new FormData();
     formData.append("file", state.uploadedFile);
     formData.append("spectra_sheet", spectraSheetInput?.value || "");
     formData.append("conc_sheet", concSheetInput?.value || "");
     formData.append("column_names", JSON.stringify(selectedCols));
     formData.append("receptor_label", receptorInput?.value || "");
     formData.append("guest_label", guestInput?.value || "");
+    formData.append("signals_sheet", ""); // placeholder for NMR flow
     formData.append("efa_enabled", efaCheckbox?.checked ? "true" : "false");
     formData.append("efa_eigenvalues", readInt(efaEigenInput?.value).toString());
     formData.append("modelo", JSON.stringify(gridData));
     formData.append("non_abs_species", JSON.stringify(nonAbsSpecies));
     formData.append("algorithm", algoSelect?.value || "Newton-Raphson");
     formData.append("model_settings", modelSettingsSelect?.value || "Free");
     formData.append("optimizer", optimizerSelect?.value || "powell");
     formData.append("initial_k", JSON.stringify(kValues));
     formData.append("bounds", JSON.stringify(kBounds));
 
     try {
-      const resp = await fetch(`${BACKEND_BASE}/process_spectroscopy`, {
-        method: "POST",
-        body: formData,  // Send as FormData, not JSON
-      });
-
-      if (!resp.ok) {
-        let text;
-        try {
-          const errJson = await resp.json();
-          text = errJson.detail || JSON.stringify(errJson);
-        } catch (_) {
-          text = await resp.text();
-        }
-        diagEl.textContent = `Error HTTP ${resp.status}: ${text}`;
-        return;
+      let data;
+      if (state.activeModule === "nmr") {
+        data = await backendApi.processNmr(formData);
+        displayNmrResults(data);
+      } else {
+        data = await backendApi.processSpectroscopy(formData);
+        displayResults(data);
+        displayGraphs(data.graphs || {});
       }
 
-      const data = await resp.json();
-
-      // Display results
-      displayResults(data);
-      displayGraphs(data.graphs);
-
     } catch (err) {
-      diagEl.textContent =
-        "Error de red: backend no disponible o petición bloqueada.\nDetalle: " +
-        (err?.message || err);
-      console.error("Process Data request failed:", err);
+      let message = `No se pudo procesar la solicitud. Detalle: ${err?.message || err}`;
+      if (err?.message?.includes("Backend no accesible")) {
+        message =
+          `No se puede contactar al backend en ${BACKEND_BASE_URL}. ` +
+          `Asegúrate de que el servidor FastAPI esté levantado y accesible.`;
+      } else if (err?.status) {
+        message =
+          `El backend devolvió un error (código ${err.status}). ` +
+          `Consulta la consola para más detalles.`;
+      }
+
+      diagEl.textContent = message;
+      console.error(`[HM Fit] Process Data request failed (${state.activeModule}):`, err);
     } finally {
       setProcessing(false);
     }
   });
 
   // Helper function to display results
   function displayResults(data) {
     if (!data.success) {
       const detail = data.detail || data.error || "Procesamiento falló.";
       diagEl.textContent = detail;
       return;
     }
 
     // Display constants and statistics
     const constants = data.constants || [];
     const stats = data.statistics || {};
 
     const fmt = (n, opts = {}) => {
       if (n === null || n === undefined || Number.isNaN(n)) return "—";
       if (opts.fixed) return Number(n).toFixed(opts.fixed);
       return Number(n).toExponential(opts.exp ?? 3);
     };
 
     const lines = [];
     lines.push("=== RESULTADOS ===", "");
     lines.push("Constantes:");
     constants.forEach((c) => {
       const name = c.name || "";
       lines.push(
         `${name}: log10(K) = ${fmt(c.log10K)} ± ${fmt(c.SE_log10K)}`
       );
       lines.push(
         `    K = ${fmt(c.K)} ± ${fmt(c.SE_K)} (${fmt(c.percent_error, { fixed: 2 })}%)`
       );
     });
 
     lines.push("", "Estadísticas:");
     lines.push(`RMS: ${fmt(stats.RMS)}`);
     lines.push(`Lack of fit: ${fmt(stats.lof)}%`);
     lines.push(`MAE: ${fmt(stats.MAE)}`);
     lines.push(`Optimizer: ${stats.optimizer || "—"}`);
     lines.push(`Eigenvalues: ${stats.eigenvalues ?? "—"}`);
 
     diagEl.textContent = lines.join("\n");
   }
 
+  function displayNmrResults(data) {
+    if (!data?.success) {
+      const detail = data?.detail || data?.error || "Procesamiento NMR falló.";
+      diagEl.textContent = detail;
+      return;
+    }
+
+    const lines = [];
+    lines.push("=== NMR WORKBOOK SUMMARY ===", "");
+    lines.push(`Traces (columns): ${data.n_traces}`);
+    lines.push(`Points (rows): ${data.n_points}`);
+    lines.push(`Concentration columns: ${data.n_concentrations}`);
+    lines.push(`Selected columns: ${(data.columns || []).join(', ')}`);
+    if (data.signals_sheet) {
+      lines.push(`Signals sheet: ${data.signals_sheet}`);
+      lines.push(`Signals detected: ${data.n_signals ?? 0}`);
+    }
+    if (data.receptor_label || data.guest_label) {
+      lines.push(`Receptor: ${data.receptor_label || '—'}`);
+      lines.push(`Guest: ${data.guest_label || '—'}`);
+    }
+
+    diagEl.textContent = lines.join("\n");
+  }
+
   function displayGraphs(graphs) {
     const plotContainers = document.querySelectorAll(".plot-placeholder");
     const prevBtn = document.getElementById("plot-prev-btn");
     const nextBtn = document.getElementById("plot-next-btn");
 
     // Clear previous content
     plotContainers.forEach((container) => {
       container.innerHTML = "";
     });
 
     const disableNav = () => {
       if (prevBtn) prevBtn.disabled = true;
       if (nextBtn) nextBtn.disabled = true;
     };
 
     const mainPlots = [];
     if (graphs.concentrations) mainPlots.push({ name: "Concentrations", data: graphs.concentrations });
     if (graphs.fit) mainPlots.push({ name: "Fit", data: graphs.fit });
     if (graphs.eigenvalues) mainPlots.push({ name: "Eigenvalues", data: graphs.eigenvalues });
     if (graphs.efa) mainPlots.push({ name: "EFA", data: graphs.efa });
     if (graphs.absorptivities) mainPlots.push({ name: "Absorptivities", data: graphs.absorptivities });
 
     // Clear secondary container explicitly (it might have old content)
     if (plotContainers[1]) {
       plotContainers[1].innerHTML = "";
diff --git a/run_backend.sh b/run_backend.sh
index c74803a682347b696fac98abe858c27dfa862a81..f42852ecc28c0747b0151b8a9e6e89e603df3d44 100644
--- a/run_backend.sh
+++ b/run_backend.sh
@@ -1,7 +1,9 @@
 #!/usr/bin/env bash
 
 # Activate the virtual environment
 source "$(dirname "$0")/venv/bin/activate"
 
 # Start the FastAPI backend on the expected port
-uvicorn backend_fastapi.main:app --host 127.0.0.1 --port 8001
+HOST="${HM_FIT_BACKEND_HOST:-127.0.0.1}"
+PORT="${HM_FIT_BACKEND_PORT:-8001}"
+uvicorn backend_fastapi.main:app --host "$HOST" --port "$PORT"
 
EOF
)
